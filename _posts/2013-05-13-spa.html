---
layout: default
title:  单页web应用
commentIssueId: 3
---

<h2> {{ page.title}} </h2>
<h3> 为什么单页web应用 SPA </h3>
<section>
  <p>
  一个页面多个组件之间的复杂交互。 组件有很多状态，加上组件的交互之后，状态的组合就 会很多。一个表单没有验证的时候， 保存的按键应该是不可点击的。 某一个表单项的验证 前提是另外一个表单项等等。 这些如果不是用SPA是很难实现的， 如果不用SPA的形式，当 一个页面刷新之后如何保持各个组建的状态是个复杂的问题。
  </p>
  <p>
  SPA的特点之一是，通过把数据和数据的表现分割开， 可以只刷新页面某一块，不需要服务器 每次都把整个页面都传递到前端。数据表现不再和服务器端有直接的联系， 而是和Model联系 在一起。当model发生变化的时候， 表现层根据modle的变化而变化。

  </p>
  <p>
  大多数的项目在开始的时候都有不切实际的雄心壮志， 同时对需要解决的问题确实一知半解。 我们对代码的实现常常超出我们对问题的理解。 没有完全理解一个问题， 我们也可以写代码， 但是因为我们没有充分理解我们需要解决的问题， 这些代码通常都没有必要的复杂。

  </p>
  <p>
  好的代码来源于多次的解决同一个问题， 也就是来源于常常说的重构。这一过程通常是发现很多 地方都有同样的模式， 我们会统一这些模式， 去掉那些特例的东西， 这些特例的东西大多数 时候产生于我们在写这些代码的时候， 没有一个更简单的方法。

  </p>
  <p>
  SPA的构架产生于和上面一样的过程：开始的时候我们用JQuery便捷的修改dom， 监听时间， 慢慢的我们发现一个标准的做法更加便捷，比如用model驱动视图。

  </p>
  <p>
  程序猿都是喜爱偷懒胜过简洁， 也就是说程序猿更在乎编程这个过程而不是编出来的东西。是 否应该在一个语句后面添加分号， 是否需要一个预处理器好可以避免写大括号都是程序猿们特爱 讨论的。兄弟， 这都是在说怎么把代码敲进去， 真正困难的是维护已有的代码。

  </p>
  <p>
  如果写出容易维护的代码呢？我们需要简洁的代码！ 我们必将持续的纠结这个问题；添加复杂度去 解决一个没有价值的东西是最容易的事情, 添加一个新的依赖、用个全局变量；同样， 不减少 复杂度地解决一个问题也是很简单的， 比如使用命名空间。

  </p>
  <p>
  抱着这些问题， 让我们看看一个摩登的SPA是如何从下面三个角度构成的：
  <ul>
    <li><strong>构架：</strong> 我们的app由那些部分组成？每个部分之间如何通讯？彼此间是怎么依赖的？</li>
    <li><strong>打包分发：</strong> 我们的app由那些文件组成？如何根据他们的逻辑关系组成模块？这些模块如何build？如何 加载到浏览器里？如何单元测试这些模块？</li>
    <li><strong>运行时状态：</strong> 当加载到浏览器后， 那些部分放到内存里？状态间如何转换？当问题发生时， 怎样知道当前 app的状态？</li>
  </ul>
</section>
<h3>摩登web应用的构架</h3>
<section>
  摩登web应用的大致的结构如下图：
  <img src="img/spa_overview.png" alt="spa overview">
  确切的说就是：
  <ul>
    <li>DOM是只写的 DOM不应该保持任何状态或是数据。应用生成HTML并且操作DOM元素， 绝对不要从DOM读取数据！ 把状态、数据写到DOM里， app很快就会失控。把数据保持在一个唯一的地方， 再由数据决定 视图要好的多， 特别是同一个数据在一个页面里有多个地方都需要展现的时候。</li>
    <li>视图观察model的改变 我们希望视图随着model的改变而改变。当多个视图依赖于一个model的时候， 我们不希望手动 同步每个视图和model。 通过使用改变事件， 我们可以让视图监听model的改变而自己做更新。</li>
    <li>
    模块解耦， 并且对外只暴露最小接口 我们应该创建小的彼此间灭有关系的模块， 而不是用全局的方法。（全局的方法不只是全局变量，还 包括单例， register 等等） 依赖使得代码难以测试，小的对外接口更有利于我们重构代码， 因为 只要我们不改对外开发的接口， 我们的重构就不会影响到使用者。
    </li>
    <li>
    最小化依赖于DOM的代码 为什么？任何依赖于DOM的代码都需要做多浏览器兼容测试。
    </li>
  </ul>
</section>


<h3>controller必死</h3>
<section>
  <p>
这也是我为什么在上面的图里不用controller这个词的原因。我不喜欢这个词，所以你也不会在本书里到 这个词。原因很简单：这个词是我们写SPA的时候从服务器端的MVC那里借来的。
</p>

<p>
当前的SPA框架里还在使用这个词， 但是我发现这个词的意思就是： 把粘合代码写在这里。就像我在一个 讲演里看到的
</p>

<p>
在DOM里添加事件，并对这些事件做出反应，渲染模板并且保持视图和model同步 如此就可以搞死Controller
</p>

<p>
让我们分别看看这些问题
</p>
SPA需要一个新的词， 因为SPA里状态的转变要比服务器端程序复杂的多：
<ul>
  <li>DOM事件可能导致视图改变</li>
  <li>model的值改变的时候会有值改变的事件</li>
  <li>应用状态改变的时候视图要转换 （比如route改变的时候）</li>
  <li>全局状态可能改变， 比如一个实时应用离线了</li>
  <li>ajax异步请求后端的延迟</li>
</ul>

<p>
这些都是需要被粘合在一起的， 而controller无力解决所有这些问题。
</p>

<p>
我们需要一个model保存数据， 需要一个视图展现数据和UI， 这都没有问题。但是代码粘合包含了几个彼此对立 的问题。我希望有勇气的人们对这些对立的问题是有不同的词， 而不是统一叫做controller
</p>
<p>
这也就是为什么本书里没有controller这个东西， 但是我会在讲述modle和view的时候带出这类问题。每个问题 都有自己的术语， 比如说事件绑定， 事件改变， 初始器等等。
</p>
  
</section>


<h3>封包</h3>
<p>
打包就是把js代码放入一个或多个文件， 然后通过script标签让浏览器加载。
</p>
<p>
似乎没有人强调过正确做这件事的重要性！打包管理不只是让你的程序加载更快， 他更多的作用是让你的app模块话 并且保证这些模块不是为测试的垃圾， 顺带提高一下性能问题。
</p>
代码是否可测试，可重构取决于， 这些代码是如何被划分为模块的从而产生一个模块话的结构。这就是打包意义： 把东西模块化，保证运行时状态不是一团糟。 比较下下面两种方法
<ul>
    <li>
     混乱随机
        <ul>
            <li>每段代码默认都是全局的</li>
            <li>命名是全局的</li>
            <li>Fully traversable namespaces ？</li>
            <li>加载顺序敏感，因为任何代码有可能被任何其他代码改变</li>
            <li>隐式依赖任何全局的东西</li>
            <li>文件和模块没有有意义的联系</li>
            <li>只能在浏览器里运行， 因为依赖没有隔离</li>
        </ul>
    </li>
    <li>
    使用包和模块
    <ul>
      <li>包没有暴露一个单一的公共接口</li>
      <li>局部变量</li>
      <li>实现透明</li>
      <li>加载顺序无关</li>
      <li>现实声明依赖关系</li>
      <li>每个文件暴露一个模块</li>
      <li>可以命令行运行</li>
    </ul>
    </li>
</ul>
<p>
默认的方式 – 每个文件都加入到全局的命名空间， 是和可怕的， 因为这样使得单元测试和重构非常空难。
</p>
<p>
除此之外， 隐士的依赖导致在重构的时候，你很难知道当前代码有那些依赖； 以级别上就只能指望其他人有 好的代码习惯了。
</p>

<h3>运行期状态</h3>
<section>
  <p>
运行期状态是第三种方式看待摩登web程序。运行期状态是指， 当你的应用在浏览器里运行的时候看起来是怎样的 -- 例如， 变量包含那些值？如何从一个状态转变为另一个状态
</p>
在此有三个有趣的关系：
<ul>
  <li><p>URL &lt;-&gt; state 单页程序和URL有这神经分裂般的关系。 一方面SPA存在的意义是用户和应用之间交互丰富。 丰富的交互意味 这view的状态要比URL里能够容纳的状态多的多。 另一方面， 我们还希望我们能够添加一个书签， 点击后可以 跳会到添加书签是的状态。</p>
  <p>
  为了支持书签， 我们可能需要缩减在URL里的细节级别。 如果一个页面有一个主要的活动（这个活动表现在url 里的某一个级别里）， 这样每个页面能够被从书签回复到足够的级别？？？ 次级的活动就会被回复到默认的状态。
  </p>
  </li>
  <li>
  <p>
  定义 &lt;-&gt; 初始化 糟糕的是， 有些童鞋经常搞不清这两者的区别。可复用的模块应该被定义但是不需要被初始化， 这样有利于复用 和测试。 但是一旦我们这么做了， 我们如何真正的初始化一个应用的状态呢？
  </p>
  <p>
  我任务大致上有三个方法： 方法一是： 每个模块都有一个小的方法， 这个方法接受到一些参数（例如ID）并且恰当的实例化视图和对象。 另一个方法是： 有一个全局的启动文件， 里面有一个路由。路由从全局状态里加载具体的状态。第三种方法 是吧所有的东西融为一体， 使得实例化顺序不可见。
  </p>

  <p>
  我喜好第一种方法， 第二种在应用成长到一定成都，事情开始纠缠不清的时候最长看到。第三种常在一些框架里 看到， 特别是处理视图层的时候。
  </p>
  </li>

</ul>
</section>
